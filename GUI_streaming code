import sys
import os
from threading import Event, Thread
import smaract.ctl as ctl
import tkinter as tk
from tkinter import ttk, filedialog

# Helper function for internal resources (if needed for other files)
def resource_path(relative_path):
    """
    Get absolute path to resource, works for development and for PyInstaller.
    """
    try:
        base_path = sys._MEIPASS  # PyInstaller temporary folder
    except AttributeError:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, relative_path)

# SmarAct MCS2 programming example: Streaming
# This example shows trajectory streaming.
# For a full command reference see the MCS2 Programmers Guide.

# Global variables
NUMBER_OF_STREAMING_CHANNELS = 2
MAX_NUMBER_OF_FRAMES = 1024
# Default file name, which the user may change via the GUI.
DEFAULT_STREAM_FILE_NAME = "mechanical_stage_lissajous.csv"
STREAM_FILE_NAME = DEFAULT_STREAM_FILE_NAME

# Status events for inter-thread communication
stream_done = Event()
stream_abort = Event()

def assert_lib_compatibility():
    """
    Checks that the major version numbers of the Python API and the
    loaded shared library match to avoid incompatibilities.
    Raises a RuntimeError if the major versions differ.
    """
    vapi = ctl.api_version
    vlib = [int(i) for i in ctl.GetFullVersionString().split('.')]
    if vapi[0] != vlib[0]:
        raise RuntimeError("Incompatible SmarActCTL python API and library version.")

def waitForEvent():
    """Wait for events generated by the connected device."""
    while True:
        try:
            event = ctl.WaitForEvent(d_handle, ctl.INFINITE)
            if event.type == ctl.EventType.STREAM_FINISHED:
                print("MCS2 {}".format(ctl.GetEventInfo(event)))
                if ctl.EventParameter.PARAM_RESULT(event.i32) == ctl.ErrorCode.NONE:
                    stream_done.set()
                elif ctl.EventParameter.PARAM_RESULT(event.i32) == ctl.ErrorCode.ABORTED:
                    print("MCS2 stream aborted by user")
                    stream_done.set()
                    stream_abort.set()
                else:
                    print("MCS2 stream aborted by device: {}".format(
                        ctl.ErrorCode(ctl.EventParameter.PARAM_RESULT(event.i32)).name))
                    stream_done.set()
                    stream_abort.set()
            elif event.type in (ctl.EventType.STREAM_READY, ctl.EventType.STREAM_TRIGGERED):
                # These events are not used with the STREAM_TRIGGER_MODE_DIRECT trigger mode.
                pass
            else:
                print("MCS2 received event: {}".format(ctl.GetEventInfo(event)))
        except ctl.Error as e:
            if e.code == ctl.ErrorCode.CANCELED:
                print("MCS2 canceled wait for event")
            else:
                print("MCS2 {}".format(ctl.GetResultInfo(e.code)))
            return

def start_streaming():
    global NUMBER_OF_STREAMING_CHANNELS, MAX_NUMBER_OF_FRAMES, STREAM_FILE_NAME, d_handle

    # Get values from the entry widgets
    try:
        NUMBER_OF_STREAMING_CHANNELS = int(num_channels_entry.get())
    except ValueError:
        print("Invalid number for channels.")
        return
    try:
        MAX_NUMBER_OF_FRAMES = int(num_frames_entry.get())
    except ValueError:
        print("Invalid number for frames.")
        return

    # Get the CSV file name/path from the entry widget.
    # (The user may have browsed for a file; if not, a default is used.)
    STREAM_FILE_NAME = stream_file_entry.get()
    if not STREAM_FILE_NAME:
        STREAM_FILE_NAME = DEFAULT_STREAM_FILE_NAME

    try:
        # Open the first MCS2 device (assuming 'locators' is defined elsewhere)
        d_handle = ctl.Open(locators[0])
        print("MCS2 opened {}.".format(locators[0]))

        # Start a thread to receive events from the controller.
        event_handle_thread = Thread(target=waitForEvent)
        event_handle_thread.start()

        # Set position zero and enable amplifier for each channel.
        for channel in range(NUMBER_OF_STREAMING_CHANNELS):
            ctl.SetProperty_i32(d_handle, channel, ctl.Property.SENSOR_POWER_MODE, ctl.SensorPowerMode.ENABLED)
            ctl.SetProperty_i32(d_handle, channel, ctl.Property.AMPLIFIER_ENABLED, ctl.TRUE)

        # Configure stream properties.
        ctl.SetProperty_i32(d_handle, 0, ctl.Property.STREAM_EXT_SYNC_RATE, 100)  # External sync rate: 100Hz
        ctl.SetProperty_i32(d_handle, 0, ctl.Property.STREAM_BASE_RATE, 50)       # Base rate: 50 (example)
        s_handle = ctl.OpenStream(d_handle, ctl.StreamTriggerMode.DIRECT)

        # The following loop assumes you have a list "stream_buffer" with frame data,
        # and a variable "no_of_frames" representing the number of frames.
        for frame_idx in range(no_of_frames):
            if stream_abort.isSet():
                break
            frame = stream_buffer[frame_idx]
            ctl.StreamFrame(d_handle, s_handle, frame)

        ctl.CloseStream(d_handle, s_handle)
        stream_done.wait()
        ctl.Cancel(d_handle)
        event_handle_thread.join()

    except ctl.Error as e:
        print("MCS2 {}: {}, error: {} (0x{:04X}) in line: {}."
              .format(e.func, ctl.GetResultInfo(e.code),
                      ctl.ErrorCode(e.code).name, e.code, (sys.exc_info()[-1].tb_lineno)))
    except Exception as ex:
        print("Unexpected error: {}, {} in line: {}".format(ex, type(ex), (sys.exc_info()[-1].tb_lineno)))
        raise
    finally:
        if d_handle is not None:
            ctl.Close(d_handle)
        print("MCS2 close.")
        print("*******************************************************")
        print("Done. Press return to exit.")
        input()

def browse_file():
    """Open a file dialog to choose a CSV file."""
    filename = filedialog.askopenfilename(
        title="Select CSV File",
        filetypes=[("CSV Files", "*.csv"), ("All Files", "*.*")]
    )
    if filename:
        stream_file_entry.delete(0, tk.END)
        stream_file_entry.insert(0, filename)

# Build the GUI using tkinter
root = tk.Tk()
root.title("MCS2 Streaming GUI")

# Label and entry for number of streaming channels
ttk.Label(root, text="Number of Streaming Channels:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
num_channels_entry = ttk.Entry(root)
num_channels_entry.insert(0, str(NUMBER_OF_STREAMING_CHANNELS))
num_channels_entry.grid(row=0, column=1, padx=5, pady=5)

# Label and entry for maximum number of frames
ttk.Label(root, text="Max Number of Frames:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
num_frames_entry = ttk.Entry(root)
num_frames_entry.insert(0, str(MAX_NUMBER_OF_FRAMES))
num_frames_entry.grid(row=1, column=1, padx=5, pady=5)

# Label and entry for CSV file name/path with a Browse button
ttk.Label(root, text="Stream CSV File:").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)
stream_file_entry = ttk.Entry(root, width=40)
stream_file_entry.insert(0, DEFAULT_STREAM_FILE_NAME)
stream_file_entry.grid(row=2, column=1, padx=5, pady=5)
browse_button = ttk.Button(root, text="Browse...", command=browse_file)
browse_button.grid(row=2, column=2, padx=5, pady=5)

# Button to start the streaming process
start_button = ttk.Button(root, text="Start Streaming", command=start_streaming)
start_button.grid(row=3, column=0, columnspan=3, pady=10)

root.mainloop()
